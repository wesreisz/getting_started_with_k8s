---
title: "Mounts & Volumes"
full_title: "Lesson 5: Mounts & Volumes"
weight: 5
date: 2020-10-23T1:00:00-00:96
draft: true
---
 Docker containers do not store persistent data. Any data written to a container's writable layer will no longer be available once the container stops running. Also, getting data written to a container back out of it for another process can be difficult. To solve the issue of persisting data from a container, Docker has several options.

 * **Volumes**: Volumes are the preferred way to store persistent data Docker containers create or use. The host filesystem also stores volumes, similar to bind mounts. However, Docker completely manages them and stores them under C:\ProgramData\docker\volumes by default.

 * **Bind mounts**: A bind mount is a file or folder stored anywhere on the container host filesystem, mounted into a running container. The main difference a bind mount has from a volume is that since it can exist anywhere on the host filesystem, processes outside of Docker can also modify it.

 * **tmpfs**: As opposed to volumes and bind mounts, a tmpfs mount is temporary, and only persisted in the host memory. When the container stops, the tmpfs mount is removed, and files written there wonâ€™t be persisted.

 (There are actually others... npipe for example is used by Windows containers. We'll focus on bind mounts and volumes).


Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker. Volumes have several advantages over bind mounts:

* Volumes are easier to back up or migrate than bind mounts.
* You can manage volumes using Docker CLI commands or the Docker API.
* Volumes work on both Linux and Windows containers.
* Volumes can be more safely shared among multiple containers.
* Volume drivers let you store volumes on remote hosts or cloud providers, to encrypt the contents of volumes, or to add other functionality.
* New volumes can have their content pre-populated by a container.
* Volumes on Docker Desktop have much higher performance than bind mounts from Mac and Windows hosts

![Types of Mounts](/getting_started_with_containerization/images/lesson5/types-of-mounts-volume.png)

 **Volumes**

 Containers are ephemeral. You stop them and the any running state is gone when you restart it. If you want to persist it, you need to map in a volume that you can save it too. When you restart, you can use that mapped volume.

If you start a container with a volume that does not yet exist, Docker creates the volume for you. The following example mounts the volume myvol2 into /app/ in the container.

Let's create some JavaScript
```javascript
const fs = require("fs").promises;
const path = require("path");

const dataPath = path.join(process.env.DATA_PATH || "./data.txt");

fs.readFile(dataPath)
  .then(buffer => {
    const data = buffer.toString();
    console.log(data);
    writeTo(+data + 1);
  })
  .catch(e => {
    console.log("file not found, writing '0' to a new file");
    writeTo(0);
  });

const writeTo = data => {
  fs.writeFile(dataPath, data.toString()).catch(console.error);
};
 ```

Now let's create a Dockerfile
 ```Dockerfile
FROM node:12-alpine
COPY --chown=node:node . /src
WORKDIR /src
CMD ["node", "index.js"]
 ```

Build it with the `-t incrementor` and then run it. NOTE: This runs and exits... it's not a web server.

 ```bash
 docker build -t incrementor .
 docker run --env DATA_PATH=/data/num.txt --mount type=volume,src=incrementor-data,target=/data incrementor
 ```

```bash
docker volumes ls
docker inspect incrementor-data
```

First time this is run, it creates the volume. Each subsequent time, it attaches to the existing volume and you see it increment. Now if you remove the container (which it's stopping after every run), the volume is still there. When you rerun and recreate the container, you reattach to the exiting volume. This is how storage is added with containers.


**Bind mounts**

 Let's say you want to run a webserver to execute some HTML. 

 Create a new directory and add a new file index.html.
 ```html
<html>
    <body>
        <h1>Hello World</h1>
        <p>
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
        </p>
    </body>
</html>
 ```

 Now go to dockerhun and file nginx. Jump down to where is says: "Hosting some simple static content". Try that. NOTE: I changed '/some/content` ${pwd} to map to the index page you just created.
 ```bash
 docker run --name some-nginx -v ${PWD}:/usr/share/nginx/html:ro -p 8080:80 -d nginx
 ```
 Leave the container and webpage running. Now go back and edit the html and refresh the browser page. You're running content mapped on your machine into a pre-baked container.

 Docker 17.06 introduced the --mount flag for standalone containers. Docker recommends using the --mount flag in favor of -v because --mount is more explicit and easier to use. The biggest difference is that the -v syntax combines all the options together in one field, while the --mount syntax separates them. Here is a comparison of the syntax for each flag.
 ```bash
 docker run --name some-nginx-with-mount --mount type=bind,source=${PWD},target=/usr/share/nginx/html,readonly -p 8080:80 -d nginx 
 ```
